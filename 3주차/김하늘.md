# 1. OAuth

### OAuth란?

- 제 3자 인증방식이다.
- OAuth를 사용해서 신뢰할 수 있는 서버에게 정보를 맡겨놓고, 접근 권한을 주는 것이다.
- 인터넷 사용자들이 비밀번호를 제공하지 않고, 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단이다. 

### 장점 및 특징

* 클라이언트 입장에서 제 3자인 리소스 서버를 통해 사용자의 신원을 확인할 수 있다. 이때, 제 3자 리소스 서버는 신뢰할 수 있는 서버여야 한다.
* 신뢰할 수 있는 서버는 Access Token을 발급해서 사용자의 식별자로 활용할 수 있게 해준다.
* Access Token 에는 리소스 서버에서 사용할 수 있는 기능의 범위와 접근 가능한 유효 시간에 대한 정보가 담겨있다.

### 과정

1. 내 서비스를 제 3 서비스에 등록한다.
2. Resource Owner 가 내 서비스에게 요청한다.
3. 내 서비스는 제 3 서비스에게 요청한다.
4. 제 3서비스는 내가 등록되어있다면, Resource Owner 에게 로그인을 요청한다.
5. Resource Owner의 인증을 위해서 내 서비스는 Resource Owner에게 로그인과 같은 것을 요청한다.
6. Redirect가 되면서 Client에게 Authorize Code를 넘겨받는다.
7. 해당 Authorize Code를이용하여 Access Token을 요청한다.
8. 체크 후 내 서비스는 Access Token을 갖게 된다.
9. 사용자는 이제 Access Token을 이용하여 내 서비스를 이용할 수 있다. 



###### 참고자료

- [OAuth2.0에 대하여... [ 보안 + 서비스 + 네트워크 ] [면접 질문] [2022]](https://murphymoon.tistory.com/entry/OAuth20%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EB%B3%B4%EC%95%88-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-2022)

- [OAuth 2.0이란?](https://luv-n-interest.tistory.com/1447)

  

# 2. Socket & Socket.io

### WebSocket vs Socket.io

* 웹 소켓 : 양방향 소통을 위한 프로토콜 
* socket.io : 양방향 통신을 위해 웹 소켓 기술을 활용하는 라이브러리 

#### WebSocket

- HTML5 웹 표준 기술
- 매우 빠르게 작동하며 통신할 때 아주 적은 데이터를 이용
- 이벤트를 단순히 듣고, 보내기만 가능

#### Socket.io

* 표준 기술이 아닌, 라이브러리

* 소켓 연결 실패 시, fallback을 통해 다른 방식으로 알아서 해당 클라이언트와의 연결을 시도함

* 방 개념을 이용해 일부 클라이언트에게만 데이터를 전송하는 브로드캐스팅이 가능

  

###### 참고자료

* [웹소켓과 socket.io](https://www.peterkimzz.com/websocket-vs-socket-io/)

  

# 3. Load Balancing

### 로드 밸런싱이란?

* 서버에 가해지는 부하를 적절하게 분산시켜주는 장치 또는 기술을 뜻함
* 서버에 트래픽이 많을 때 다른 서버에 분산시키기 위해 사용함

### 대표적인 알고리즘

* 라운드 로빈 : 우선순위를 두지 않고, 순서대로 시간 단위로 배정하는 알고리즘
* 최소연결방식 : 가장 연결이 적은 서버에 배정하는 알고리즘

### L4 로드 밸런싱 / L7 로드 밸런싱

* L4 로드밸런싱 : 4계층의 정보를 바탕으로 트래픽을 분산시킴. 정보를 보지 않고 패킷 레벨에서만 트래픽을 분산하므로 속도가 빠르고 효율성이 높음.
* L7 로드밸런싱 : 7계층의 정보를 바탕으로 요청을 분산시킴. 사용자가 요청한 정보를 바탕으로 트래픽을 분산하기 때문에 섬세한 라우팅이 가능하고, 비정상적인 트래픽을 판별할 수 있다.



###### 참고자료

* [백엔드 면접 질문](https://yeo-computerclass.tistory.com/421)

  

# 4. Blocking & Non-Blocking I/O

### Blocking I/O

* I/O 작업이 진행되는 동안 유저 프로세스가 자신의 작업을 중단한 채, I/O가 끝날 때까지 대기하는 방식

### Non-Blocking I/O

* A함수가 I/O 작업을 호출할 때, I/O 작업이 완료될 때까지 A함수의 작업을 중단하는게 아니라, I/O 호출에 대해 즉시 리턴을 하고, A함수가 이어서 다른 일을 수행할 수 있도록 하는 방



###### 참고자료

* [blocking I/O, non-blocking I/O에 대하여(sync, async와의 차이)](https://etloveguitar.tistory.com/140)

# 5. 'www.google.com' 을 주소창에서 입력하면 일어나는 일

### 1. 🖥️데이터를 받아오는 과정

---

##### (1) www.google.com 입력 시, 입력한 URL 주소 중, 도메인 이름에 해당하는 google.com 을 DNS 서버에서 검색한다.

##### (2) 가장 가까운 DNS 서버에서, 해당 도메인 이름에 해당하는 IP주소를 찾아, 사용자가 입력한 URL 정보와 함께 전달합니다.

##### (3) 전달받은 IP주소를 이용해서, 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 html 문서를 요청합니다.

##### (4) WAS와 데이터베이스에서 웹 페이지 작업을 처리합니다.

	* WAS 는 서버의 일을 돕는 조력자 역할을 수행함. 사용자의 컴퓨터나 장치에 웹 어플리케이션을 수행해주는 미들웨어임. WAS는 웹 서버의 요청을 받아 동적인 페이지 처리를 담당하고, DB에서 필요한 데이터 정보를 받아 그에 맞는 파일을 생성한다. 

##### (5) WAS에서의 작업 처리 결과들을 웹 서버로 전송하고, 웹 서버는 웹 브라우저에게 html 문서 결과를 전달한다. 

 * 전달 과정에서 status code 를 통해 서버 요청에 따른 결과 및 상태를 전달함.

   

### 2. 🌟웹 브라우저에 렌더링되는 과정

---

##### (1) Critical Rendering Path를 통해 웹 브라우저 화면에 웹 페이지 내용을 출력한다.

##### (2) DOM 트리 빌드 

* 이전 단계에서 통신을 통해 받아온 html 파일들은 바이트 형태이므로 바이트 -> 문자 -> 토큰 -> 노드 -> 객체 모델로 전환하는 작업이 수행됨.

##### (3) CSSOM 트리 빌드

* html에서 사용했던 객체 모델로 전환하는 작업이 CSS 파일에도 똑같이 적용됨.
* CSSOM 트리 형태를 만들어, 특정 객체에 최종 스타일을 계산할 때, 상위 객체의 스타일을 하향식 규칙을 적용하는 방식으로 계산되는 스타일을 재귀적으로 세분화함.

##### (4) Render Tree 생성

* 기존에 제작된 DOM 과 CSSOM 을 결합해 만듦.
* 렌더링에 필요한 노드만 선택해, 페이지를 렌더링함.

##### (5) Layout

* Render Tree의 노드들에 대한 위치와 크기를 계산하는 단계임.
* 페이지 상에 존재하는 객체의 크기를, 렌더링 트리의 루트부터 시작해서, 모든 객체의 정확한 위치와 크기를 계산함.

##### (6) Paint

* 계산된 값들을 기반으로 화면에 필요한 요소들을 실제로 그리는 작업을 실행함.
* 레이아웃 단계에서 계산된 모든 위치, 크기를 실제 픽셀러 변환해서 화면에 출력함.

##### (7) Reflow & Repaint

* 특정 액션과 이벤트에 따라, html 요소의 크기나 위치를 변경해야하는 경우가 발생하며, 그 과정을 reflow라고 함. 
* 해당 과정 발생 시, 렌더링 트리와 각 요소들의 크기와 위치를 다시 계산해야함. 
* reflow 와 repaint 를 최대한 줄여야 성능 최적화와 연결됨.

##### (8) Compositoin

* 레이아웃과 페인트를 수행하지 않고, 레이어의 합성만 실행시키는 단계임.

##### (9) www.google.com 에 맞는 화면이 웹 브라우저에 출력됩니다.



###### 참고자료

* [주소창에 www.google.com을 입력했을 때 일어나는 과정](https://velog.io/@tnehd1998/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-www.google.com%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%96%88%EC%9D%84-%EB%95%8C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%BC%EC%A0%95#:~:text=1.%20www.google.com,%EC%99%80%20%ED%95%A8%EA%BB%98%20%EC%A0%84%EB%8B%AC%EC%9D%84%20%ED%95%A9%EB%8B%88%EB%8B%A4.)

