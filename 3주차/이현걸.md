## CS 스터디 3주차

### Auth
* 인증으로 확인한 결과로부터 사용자별 권한에 따라 사용할 수 있는 서비스를 허락하는 것을 허가(Authorization)라 부른다.
* 예를 들어, 인스타그램에서 'XXX'라는 사용자 계정이 인증됐을 때 'XXX' 계정의 이름의 게시에 대해서는 수정 및 열람을 허락하고, 그 이외의 계정의 게시에 대해서는 열람만 허락하는 것이 허가이다.
* 최근에는 인스타그램 이외의 제삼자가 제공하는 스마트폰 어플리케이션이나 웹사이트로부터 게시를 수행하는 등, 사이트를 넘나드는 사용도 증가하고 있다. 여기에는 사이트를 넘나드는 허가가 필요하며, 이런 사용을 실현하기 위해 다양한 방법이 개발되어 있다.

**- OAuth**
* OAuth란 사이트를 넘나들어 허가를 구현하기 위해 표준화된 프로토콜이다. 기능 자체는 허가뿐이며, 인증을 수행하지 않는다. 그렇기 때문에 기본적으로 인증을 수행하는 다른 프로토콜과 함께 사용된다. 사용할 서비스는 '리소스'라 불리며, 서비스를 제공하는 서버는 리소스 서버, 그 사용자는 리소스 오너, 허가 받은 리소스를 사용하는 웹사이트나 애플리케이션을 클라이언트라 부른다.
* 클라이언트가 리소스를 사용할 때는 리소스 오너에게 허가를 요청하고, 허가를 받으면 리소스 서버에 허가를 받은 것을 보고한 뒤, 리소스를 사용하기 위한 시크릿(토큰) 발행을 의뢰한다. 리소스 서버는 정당한 허가 여부를 확인한 뒤 토큰을 발행하며, 클라이언트는 발행된 토큰을 사용할 수 있게 된다.
* :그림과 작동 원리로 쉽게 이해하는 웹의 기초 p.158

### Socket & Socket.io
**- 소켓**
* 두 프로그램이 서로 데이터를 주고 받을 수 있게 양쪽에 생성되는 통신 단자이다. 이러한 소켓을 활용해서 하는 통신을 소켓 통신이라고 한다. 
* 양방향 소통 : 통상적인 Http 통신은 클라이언트가 요청을 보내는 경우에만 서버가 응답하는 단방향 통신이었다면, 웹소켓은 클라이언트와 서버가 서로에게 원할 때 데이터를 주고 받을 수 있다.
* 실시간 네트워킹 : 웹 환경에서 연속된 데이터를 빠르게 노출시킬 경우 즉, 채팅, 주식, 비디오 데이터 등에서 사용된다. 여러 단말기에 빠르게 데이터를 교환한다.

**- 소켓 통신**
* 소켓 통신은 서버-클라이언트의 양방향 통신을 위한 방법 중 하나이며, HTML5에서 표준으로 등록되었음.

**- 웹 소켓 프로토콜 특징**
* 최초 접속에서 http 프로토콜에서 핸드쉐이킹하기 때문에 http header을 사용한다. (http 80, http 443 포트 사용)
* 프레임으로 구성된 메세지라는 논리적 단위로 송수신한다.
* 메세지에 포함될 수 있는 교환 가능한 메세지는 테스트, 바이너리이다.

**- 웹 소켓의 한계**
* 웹 소켓은 HTML5의 기술로 그 이전 기술로 구현된 서비스는 Socket.io 와 SockJs를 이용해야 한다.
* 브라우저와 웹 서버의 종류와 버전을 파악하여 가장 적합한 기술을 선택하여 사용해야 함
* 웹 소켓은 문자열들을 주고 받는 기능만 제공한다. 그래서 주고 받은 문자열의 해독은 어플리케이션 단에서 해결한다.
* 또한 HTTP같은 경우 형식이 있기 때문에 해석할 수 있지만 웹 소켓은 형식이 정해져있지 않기 때문에 어플리케이션에서 쉽게 해석하기 힘들다. * 그래서 웹소켓은 sub-protocols을 사용해 주고받는 메세지의 형태를 약속하는 경우가 많다.

**- STOMP(Simple Text Oriented Message Protocol)**
STOMP는 웹소켓 위에서 동작하는 프로토콜로 채팅 통신을 하기 위한 형식을 정의한다. HTTP와 유사하게 정의되어 해석하기 편한 프로토콜이다.


### 로드 밸런싱(Load Balancing)
**- 로드 밸런서**
* 네트워크의 구성을 결정한 후, 각 네트워크에 배치할 서버 구성을 검토해야 한다. 각 서버의 역할을 고려해 어떤 서버 기기로 작동시킬 것인지, 서버 배치 대상 네트워크를 어디로 할 것인지, 서버 다중화를 수행할 것인지 등을 중심으로 구성을 검토한다.
* 웹서버를 다중화할 때 시스템에 도착하는 요청을 어떤 웹서버로 전달할 것인지 고려할 필요가 있음.
* 이 분배 작업을 로드 밸런싱이라고 하며, 이 작업을 수행하는 기기를 로드 밸런서(Load Balancer)라고 부른다.
* 로드 밸런서는 웹서버보다 인터넷 쪽에 배치하고, 그 아래에 있는 웹서버를 인식시킨다.
* 클라이언트로부터의 요청을 로드 밸런서가 우선적으로 모두 받은 뒤, 해당 요청을 아래의 웹서버에 균등하게 전송함으로써 웹서버의 부하를 평준화하면서 요청을 처리하게 한다. 웹서버로부터의 응답도 우선 로드 밸런서가 받아, 로드 밸런서가 클라이언트로 반환한다.
* :그림과 작동 원리로 쉽게 이해하는 웹의 기초 p.171

**- 로드 밸런싱**
* 여러 대의 서버를 병렬로 배치하고 요청을 나눠서 병행으로 실행함으로써 각 서버의 부하를 줄이는 방법을 부하 분산(Load Balancing)이라 부른다. 부하 분산을 수행하면 각 서버의 처리량은 줄어들기 때문에 각 서버의 성능이 낮아도 시스템 전체적으로는 많은 접근을 처리할 수 있게 된다. 그리고 여러 서버에서 같은 처리를 실행하므로, 일부 서버가 고장 나더라도 하나라도 그 역할을 분담하는 서버가 남아 있다면 서비스를 유지할 수 있는 다중화 효과도 얻을 수 있다.

* 부하 분산 방식은 여러 가지가 있으며, 기기나 소프트웨어에 따라 실행할 수 있는 방법이 다르다.

**- 라운드 로빈 방식**
* 각 서버에 순서대로 요청을 분배하는 방식이다. 각 요청을 처리하는 복잡도가 비슷한 정도이고, 각 서버의 처리 능력이 비슷할 경우 효과적이다. 단, 요청 처리의 복잡도가 다른 경우에는 서버 부하의 편차가 커지게 된다.

**- 동적 분산 방식**
* 서버 부하를 감시해, 부하가 작은 서버에 우선적으로 요청을 분배하는 방식이다. '서버 부하' 기준으로는 CPU 사용률이나 메모리 사용량, 디스크 부하, 커넥션 수 등을 사용한다.

**- 퍼시스턴스**
* 부하 분산을 수행하면 같은 클라이언트로부터의 접근이라도 매번 분배되는 서버가 다르므로 로그인해서 사용하는 등의 사이트에서는 세션 정보를 관리하기가 어렵다. 그래서 같은 클라이언트로부터의 접근을 판별해, 항상 같은 서버로 전송하는 기능이 개발되었다. 이를 퍼시스턴스라고 부른다.
* :그림과 작동 원리로 쉽게 이해하는 웹의 기초 p.174


### Blocking & Non-Blocking I/O
**- Blocking VS Non-Blocking**
* 호출되는 대상이 직접 제어할 수 없는 경우와 관련된 구분
* Blocking: 직접 제어할 수 없는 대상의 작업이 끝날 때까지 기다려야 하는 경우, 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 주지 않는 것.
* Non-Blocking: 직접 제어할 수 없는 대상의 작업이 완료되기 전에 제어권을 넘겨주는 경우, 제어할 수 없는 대상의 작업 처리 여부와 상관이 없음.

**- Synchronous VS Asynchronous**
* 두 가지 이상의 대상(메서드, 작업, 처리 등)과 이를 처리하는 시간으로 구분한다.
* Synchronous: 호출된 함수의 리턴하는 시간과 결과를 반환하는 시간이 일치하는 경우
* 두 가지 이상의 대상이 서로 시간을 맞춰 행동
* 호출한 함수가 호출 된 함수의 작업이 끝나서 결과를 반환하기를 기다림
* 지속적으로 호출된 함수에게 확인 요청

* Asynchronous: 호출된 함수의 리턴하는 시간과 결과를 반환하는 시간이 일치하지 않는 경우
* 동기와 반대로 서로 시간을 맞추지 않는 것
* 호출한 함수가 호출 된 함수에게 작업을 맡겨놓고 신경을 안쓰는 것

### 'www.google.com'을 주소창에서 입력하면 일어나는 일
* 참고 : https://j-ho.dev/cs-4/
* 1. 브라우저는 캐싱된 DNS 기록들을 통해 google.com과 대응되는 IP 주소가 있는지 확인한다.
- 브라우저 캐시 확인 → OS 캐시 확인 → router 캐시 확인 → ISP 캐시 확인
* 2. 요청한 URL이 캐시에 없으면, ISP의 DNS 서버가 google.com을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날린다.
- 이러한 검색을 recursive search라고 부른다.
- 처음에 DNS recursor가 root name server에 연락 
- → root name server는 .com 도메인 name server로 리다이렉트 
- → .com name server는 google.com name server로 리다이렉트 
- → google.com name server는 DNS 기록에서 google.com에 매칭 되는 IP 주소를 찾고 DNS recursor로 보낸다.
* 3. 브라우저가 서버와 TCP connection을 한다.
- → 클라이언트가 SYN 패킷을 서버에 보내고 connection을 열어달라고 물어본다.
- → 서버가 새로운 connection을 시작할 수 있는 포트가 있다면 SYN/ACK 패킷으로 대답을 한다.
- → 클라이언트는 SYN/ACK 패킷을 서버로부터 받으면 서버에게 ACK 패킷을 보낸다.
* 4. 브라우저가 웹 서버에 HTTP 요청을 한다.
- 클라이언트의 브라우저는 GET 요청을 통해 서버에게 google.com 웹 페이지를 요구한다.
- 요청을 할 때 비밀 자료들을 포함하던지, form을 제출하는 상황에서는 POST 요청을 사용할 수도 있다.
* 5. 서버가 요청을 처리하고 response를 생성한다.
- 서버는 웹 서버를 가지고 있다.(NginX, NodeJs, Apache, IIS…) 이들은 브라우저로부터 요청을 받고 Request handler한테 요청을 전달해서 요청을 읽고 response를 생성하게 된다.
- Requset handler란 Python, Go, JS, JAVA 등으로 작성된 프로그램을 의미한다.
- 이 Request handler는 요청과 요청의 헤더, 쿠키를 읽어서 요청이 무엇인지 파악하고 필요하다면 서버에 정보를 업데이트한다.
- 그다음에 response를 특정한 포맷으로 작성한다. (ex: JSON, XML, HTML)
* 6. 서버가 HTTP response를 보낸다.
- 서버의 response에는 요청한 웹 페이지, status code, compress type(Content-Encoding), Cache-Control, 설정할 쿠키가 있다면 쿠키, 개인 정보 등이 포함된다.
* 7. 브라우저가 HTML content를 보여준다.
