* Array



* LinkedList



* ArrayList vs LinkedList



* HashTable



* 스택(Stack) & 큐(Queue)



* 그래프(Graph) & 트리(Tree)



* 힙(Heap)



* 이진탐색트리(Binary Search Tree)



* 트라이(Trie)

문자열을 효율적으로 처리하기 위한 트리 자료구조
단어 S를 삽입/탐색/삭제할 때, O(|S|)의 시간복잡도로 처리 가능. (|S| = 단어 S의 길이)
단점: 메모리를 많아 차지함. 단어들을 평범하게 배열에 저장하는것과 비교했을때 4 x ‘글자의 종류’배 만큼 더 사용
ex)알파벳 대문자: 26 *4 = 104배 더 사용
일반적인 문자열의 삽입/삭제/검색은 해시나 이진 검색 트리를 쓰는것이 메모리와 시간 측면 모두 효율적이고 구현이 쉽다.

삭제가 빈번하게 발생하는 환경에서는 트라이가 적합하지 않음
왜냐하면 트라이에서 단어를 삭제할때 점을 삭제하는것이 아니라 해당 단어가 있다는 ‘표식’만 삭제하게 되어서, 이전에 삽입한 정점들은
메모리에 계속 남아있게 되기 때문임.




* B-Tree & B+Tree




q) 데이터베이스에서 인덱스를 만들때 해쉬를 사용하지 않고 B+를 이용하는 이유는?
https://helloinyong.tistory.com/296

q) 그렇다면 포인터를 가진 Linked List를 사용하지 않는 이유는?



* 정렬 알고리즘(Quick Sort, Merge Sort)


