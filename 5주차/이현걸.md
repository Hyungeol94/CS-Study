## CS 스터디 5주차

### CPU 스케줄링
* 스케줄링은 여러 프로세스가 번갈아 사용하는 자원(=프로세서)를 어떤 시점에 어떤 프로세스에 할당할지 결정하는 것이다. 스케줄링이 잘 이루어진다면, 프로세서의 효율성이 높아지고, 작업(프로세스)의 응답시간이 최소화되어 시스템의 작업 처리 능력이 향상된다.

| 스케줄링이 필요하지 않은 프로세스                               | 스케줄링이 필요한 프로세스                                |
|-----------------------------------------------------------------|-----------------------------------------------------------|
| 인터럽트 처리,  오류 처리,  사용자의 시스템 호출 등의 사전 처리 | 사용자 프로세스,   시스템 호출로 발생하는 시스템 프로세스 |

**- 프로세스의 동작**
* 프로세스 버스트(process burst): 프로세스를 프로세서에서 실행할 때
* 입출력 버스트: 프로세스가 추가로 실행하려고 입출력을 기다리고 있을 때
* 프로세스 버스트가 짧고 입출력 버스트가 긴 프로세스를 입출력 중심 프로세스라 한다. 이와 반대로 프로세스 버스트가 길고 입출력 버스트가 짧은 프로세스를 프로세서 중심 프로세스라고 한다.

**- 스케줄링의 단계**
* (1단계) 작업 스케줄링
- 디스크에 있는 작업 중 실제로 시스템 자원을 사용할 작업을 결정하고, 작업을 프로세스들로 나눠 생성한다.  
* (2단계) 작업 승인과 프로세서 결정 스케줄링
- 프로세서를 사용할 권한을 가질 프로세스를 결정하는 '작업 승인'과, '프로세서 결정 스케줄링'을 한다.
- 시스템의 오버헤드에 따라 연기할 프로세스를 잠정적으로 결정하면서, 1단계 스케줄링과 3단계 스케줄링의 완충 역할을 한다.
* (3단계) 프로세서 할당 스케줄링 : 준비 상태의 프로세스에 프로세서 할당(디스패칭)
- 이 단계에서는 프로세서를 할당할 프로세스를 결정한다. 단, 프로세스는 디스패처(분배기)가 준비 상태에 있어야 한다.

**- 스케줄링 큐**
* 스케줄링 큐는 프로세스 제어 블록의 연결 리스트 형태로 구현되어 있다.
* 스케줄링 큐는 크게 '준비 큐'와 '입출력장치 큐'로 나눌 수 있다. 
* 준비 큐는 시스템에 하나씩만 있으며, 프로세서를 할당받아 실행되기를 기다리는 프로세스들이 대기한다. 좁은 의미에서 스케줄링은 준비 큐에서 프로세스를 하나 선택하는 것이다.
* 입출력장치 큐는 하나의 시스템에 여러 개가 있을 수 있다(ex.  프린터, 디스크, 단말기 등). 전용장치의 경우(ex. 테이프 드라이브, 시분할 단말기 등)에 입출력장치 큐는 하나의 프로세스만 가질 수 있는 반면, 디스크와 같이 공유할 수 있는 장치의 경우에 입출력장치 큐에 여러 프로세스가 대기할 수 있다.


### 캐시(Cache)란
* 캐시 메모리는 컴퓨터 시스템에서 중요한 역할을 하는데, 속도 차이에 따른 병목 현상을 줄이고 성능을 향상시키는 역할을 한다. 

**- 캐시 메모리의 역할과 기능**
* 캐시 메모리는 컴퓨터의 중요한 부분 중 하나로, CPU와 주기억장치 간의 데이터 전송 속도 차이를 극복하기 위한 중간 저장 공간으로 사용된다. CPU는 주기억장치에서 데이터를 읽어오는데, 이때 자주 사용하는 데이터를 캐시 메모리에 저장한 후, 다음에 필요할 때 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다. 이러한 방식은 빠른 속도를 제공하지만, 캐시 메모리의 용량은 제한적이며 비용이 비싸다는 단점이 있다. CPU에는 일반적으로 L1, L2, L3 캐시 메모리가 있으며, 이들은 속도와 크기에 따라 분류된다. 일반적으로 L1 캐시가 가장 먼저 사용되며, 데이터를 찾지 못할 경우 L2로 이동한다.

* 코어 프로세서의 경우 각 코어마다 독립된 L1 캐시 메모리를 가지고 있으며, 두 코어가 공유하는 L2 캐시 메모리가 내장되어 있다. 이것은 캐시 메모리의 구조 중 하나로, 캐시의 효율적인 사용을 위한 중요한 구성 요소이다.


**- 캐시 메모리의 작동 원리**
* 시공간 지역성: 시간 지역성은 한 번 참조된 데이터가 잠시 후에 다시 참조될 가능성이 높다는 원리를 의미하며, 공간 지역성은 연속적으로 참조되는 데이터 근처에 있는 데이터가 잠시 후에 다시 사용될 가능성이 높다는 원리를 나타낸다. 따라서 캐시에 데이터를 저장할 때는 이러한 지역성을 활용하여 해당 데이터뿐만 아니라 인접한 데이터도 함께 가져와 미래 사용에 대비한다.

* 캐시 메모리의 구조 및 작동 방식은 Direct Mapped Cache, Fully Associative Cache, Set Associative Cache 등으로 나뉜다. 

* 캐시 메모리의 쓰기 정책은 Write Through와 Write Back으로 나뉜다. 또한, 주소 매핑 방식은 Direct Mapping, Associative Mapping, Set Associative Mapping 등이 있으며, 이를 통해 캐시와 주기억장치의 주소 관리를 한다.

* 마지막으로, 캐시 메모리의 교체 알고리즘으로는 FIFO, LRU, LFU, OPTIMAL 방식이 있으며, 각각의 방식은 특정 상황에 더 효율적이다.

**- 캐시 미스**
* Cold miss: 처음 불러오는 경우
* Conflict miss: 데이터 충돌로 인한 미스
* Capacity miss: 용량 부족으로 인한 미스

### 데드락(DeadLock)
* 데드락은 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 못하는 상태이다. 데드락은 주로 네 가지 조건으로 발생한다: 상호 배제, 점유 대기, 비선점, 순환 대기.

* 상호 배제 조건은 자원을 한 번에 하나의 프로세스만 사용할 수 있도록 하는 것을 의미한다. 이것을 제거하는 것은 일반적으로 불가능하다. 

* 점유 대기 조건은 프로세스가 이미 자원을 보유한 상태에서 다른 자원을 기다릴 때 발생한다. 이 조건을 없애기 위해 모든 필요한 자원을 한 번에 할당하거나, 자원을 요청할 때 보유한 자원을 모두 놓고 다시 요청하는 방법이 있다. 그러나 이렇게 하면 자원 이용률이 감소하고 오버헤드가 발생할 수 있다.

* 비선점 조건은 자원을 점유한 프로세스가 자발적으로 자원을 내놓기 전까지는 다른 프로세스에게 선점되지 않는다는 것이다. 이 조건을 없애기 위해선 자원을 선점할 수 있는 방법을 도입해야 한다.

* 순환 대기 조건은 프로세스가 자원을 순환적으로 기다릴 때 발생한다. 이를 방지하기 위해 자원 요청에 대한 순서를 정해야 한다.

**- 데드락을 예방하는 방법**
데드락을 예방하는 방법으로는 상호 배제 조건을 제거하거나, 점유 대기 조건을 제거하거나, 비선점 조건을 제거하거나, 순환 대기 조건을 제거하는 방법이 있다. 그러나 이러한 방법들은 효율성이나 구현의 어려움 등 다양한 제약 사항이 따르며, 일반적으로 모든 조건을 동시에 제거하는 것은 어렵다.

데드락을 회피하는 방법으로는 자원 할당 그래프 알고리즘과 은행원 알고리즘이 있다. 자원 할당 그래프 알고리즘은 자원 할당 상태를 검사하여 데드락 가능성을 판단하고, 안전한 경우에만 자원을 할당한다. 은행원 알고리즘은 프로세스가 자원을 요청할 때 시스템이 안전 상태를 유지할 수 있는지를 미리 판단하여 자원을 할당한다.

**- 데드락에 대한 대처 방법**
데드락이 발생하면 복구하기 위해 프로세스 종료 또는 자원 뺏기와 같은 방법을 사용할 수 있다. 그러나 이러한 방법은 프로세스의 중단이나 자원의 선점으로 인한 오버헤드가 발생할 수 있다.

마지막으로, 데드락을 무시하는 방법도 있지만, 이것은 데드락이 발생할 때마다 시스템을 멈추고 복구하는 것이 아니라 무시하고 계속 작업을 수행하는 방법이다. 이 방법은 데드락이 드물게 발생하는 경우에 사용할 수 있으며, 대부분의 범용 운영 체제가 이 방법을 채택하고 있다.

### Race Condition
### 세마포어(Semaphore) & 뮤텍스(Mutex)
### 페이징 & 세그먼테이션 (PDF)
### 페이지 교체 알고리즘