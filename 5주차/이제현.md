5주차

	•	CPU 스케줄링

등장배경: CPU 활용을 극대화하기 위해 멀티프로그래밍이 필요하다. 그런데
CPU core 한개로는 한번에 하나의 프로세스만 동작할 수 있다.
그렇기 때문에 CPU 스케줄링이 필요함
CPU 스케줄러는 메모리에 있는 프로세스 중 하나를 골라서 CPU에 할당해줌.
CPU 스케줄링은 waiting state -> ready state-> ready.. process 상태들에 개입하는데
스케줄링이 이 과정에서만 일어진다면 non-preemptive(비선점형) / cooperative라고 부름
나머지는 preemptive(선점형 스케줄링)임. 이게 요즘 자주 쓰는 방식임

I/O bound process: CPU burst(CPU 명령을 실행하는 시간)가 I/O burst보다 짧 
CPU bound process: I/O burst(I/O를 요청ㅇ한 다음 기다리는 시간)가 CPU burst보다 짧

스케줄링 알고리즘 종류

-FCFS : 먼저오는 프로세스가 먼저 CPU에 할당됨
![](img_이제현/FCFS.png)

문제점: Convoy effect (CPU burst 긴게 들어오면 짧은놈들은 오래 기다려야해서 CPU utilization 저조해짐)


-SJF(Shortest Job First)
선점형(=Shortest Remaining Time First, SRTF) vs 비선점형
평균 waiting time이 최소일때 유리. 다음 CPU burst 길이의 예측값을 아는게 어려움
예측방법 -> exponential averaging

![](img_이제현/non-preemptive_SJF.png)

burst time이 같을 때는 먼저 들어온거를 도중에 중단시키지 않고 쭉


![](img_이제현/preemtive_SJF.png)

먼저 들어온 process를 실행하다가도 더 짧은게 있다면 대체


-Priority Scheduling
정수의 우선순위가 프로세스별로 할당되고 숫자가 낮은 순으로 CPU 우선 할당됨




-Round-Robin Scheduling



-Multilevel Queue Scheduling





-Multilevel Feedback Queue Scheduling



	•	캐시(Cache)란


-Cache hit ratio

	•	데드락(DeadLock)


	•	Race Condition


	•	세마포어(Semaphore) & 뮤텍스(Mutex)


	•	페이징 & 세그먼테이션 (PDF)


	•	페이지 교체 알고리즘
