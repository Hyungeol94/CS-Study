5주차

	•	CPU 스케줄링

등장배경: CPU 활용을 극대화하기 위해 멀티프로그래밍이 필요하다. 그런데
CPU core 한개로는 한번에 하나의 프로세스만 동작할 수 있다.
그렇기 때문에 CPU 스케줄링이 필요함
CPU 스케줄러는 메모리에 있는 프로세스 중 하나를 골라서 CPU에 할당해줌.
CPU 스케줄링은 waiting state -> ready state-> ready.. process 상태들에 개입하는데
스케줄링이 이 과정에서만 일어진다면 non-preemptive(비선점형) / cooperative라고 부름
나머지는 preemptive(선점형 스케줄링)임. 이게 요즘 자주 쓰는 방식임

I/O bound process: CPU burst(CPU 명령을 실행하는 시간)가 I/O burst보다 짧 
CPU bound process: I/O burst(I/O를 요청ㅇ한 다음 기다리는 시간)가 CPU burst보다 짧

스케줄링 알고리즘 종류

-FCFS : 먼저오는 프로세스가 먼저 CPU에 할당됨
![](img_이제현/FCFS.png)

문제점: Convoy effect (CPU burst 긴게 들어오면 짧은놈들은 오래 기다려야해서 CPU utilization 저조해짐)


-SJF(Shortest Job First)
선점형(=Shortest Remaining Time First, SRTF) vs 비선점형
평균 waiting time이 최소일때 유리. 다음 CPU burst 길이의 예측값을 아는게 어려움
예측방법 -> exponential averaging

![](img_이제현/non-preemptive_SJF.png)

burst time이 같을 때는 먼저 들어온거를 도중에 중단시키지 않고 쭉


![](img_이제현/preemtive_SJF.png)

먼저 들어온 process를 실행하다가도 더 짧은게 있다면 대체


-Priority Scheduling
정수의 우선순위가 프로세스별로 할당되고 숫자가 낮은 순으로 CPU 우선 할당됨
문제점: Starvation(=indefinite blocking) - 우선순위가 낮은 프로세스는 실행 안될수도
해결책: aging - 대기하고 있는 process들의 우선순위를 상승시킴

-Round-Robin Scheduling
각각의 프로세스는 time quantum(=time slice)라는 작은 CPU time unit을 가지는데, 이 시간이 지나면 프로세스가 선점되고 ready queue에 들어감.
P1 P2 P3 P4 프로세스의 burst time이 각각 53,17,68,24이며 Time quantum이 20일때
t_1 = 33/0/48/4 ..

SJF보다 average turnaround time이 높지만, 반응이 좋음. Time quantum이 너무 크면 FCFS이 되어버림. q는 context switch 정도의 시간 크기와 맞춰야함. 
cf) q가 극단적으로 작으면 process sharing이 되어버림.

80 percent rule이란?


-Multilevel Queue Scheduling





-Multilevel Feedback Queue Scheduling



	•	캐시(Cache)란


-Cache hit ratio

	•	데드락(DeadLock)
두 개 이상의 프로세스가 




	•	Race Condition





	•	세마포어(Semaphore) & 뮤텍스(Mutex)

 process 안에는 critical section이라고 부르는 코드 segment가 존재하는데, 이를 구현하는 소프트웨어적인 접근. 


	•	페이징 & 세그먼테이션 (PDF)


	•	페이지 교체 알고리즘
